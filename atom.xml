<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Either a Blog</title>
    <link href="http://blog.timsears.com/atom.xml" rel="self" />
    <link href="http://blog.timsears.com" />
    <id>http://blog.timsears.com/atom.xml</id>
    <author>
        <name>Tim Sears</name>
        <email>tim@timsears.com</email>
    </author>
    <updated>2014-12-13T00:00:00Z</updated>
    <entry>
    <title>I am trying nix - Part 2</title>
    <link href="http://blog.timsears.com/posts/morenix.html" />
    <id>http://blog.timsears.com/posts/morenix.html</id>
    <published>2014-12-13T00:00:00Z</published>
    <updated>2014-12-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is an update on how I am getting along with nixos/nix since <a href="http://blog.timsears.com/posts/im_trying_nix.html">last time</a>. At that point I had only installed nixos, added a few essential packages and even started editing and generating this blog on the new system. Now I want to play around with bleeding edge Haskell code and not pay a heavy price in terms of system configuration. If I can continue on from there to develop production code I will consider the experiment a success and may migrate to using nixos full-time.</p>
<h1 id="about-nix">About nix</h1>
<p><a href="http://nixos.org/nixos">Nixos</a> is a linux distribution that uses the nix package manager to manage your system, while <a href="http://nixos.org/nix">nix</a> is a package manager that can be used on a variety of systems, perhaps as a replacement for homebrew on mac, or in addition to apt-get on ubuntu. There is also a cloud management tool called nixops that is very interesting in its own right.</p>
<p>One of the big draws of nix is the idea that it sandboxes <em>everything</em>. That means every package you install keeps track of all its inputs and outputs in <code>/nix/store</code>. Nix manages your environment by adding and removing packages from the various paths that make up your environment. Conflicting packages can easily coexist on the system, since every package can specify all its dependencies in complete ignorance of other packages. Some Haskell devs have moved to nix to avoid so called ‚Äúcabal hell‚Äù. Cabal sandboxes, especially the newer version, work fine for many users, but nix also covers code outside of Haskell and makes it easier, in my opinion at least, to support multiple versions of ghc on your dev box.</p>
<p>I have never gotten the hang of running multiple ghc versions on my ubuntu dev box and have never seen a solution that looked easy to manage. Frankly, I am a coward, since I use my dev box to produce production code, and I don‚Äôt want to break anything besides my own code. Of course breaking things is probably the best way to learn. Nix promised to make it easy for the cowardly and fearless me to work on the same box. That‚Äôs a very enticing claim to test.</p>
<h1 id="first-some-tips">First Some Tips</h1>
<p>So far the learning curve for nix has been steep, though maybe less steep than learning Haskell. Before doing some more serious hacking, here are some suggestions that a ‚Äúnormal‚Äù Haskell developer like me might wish to consider to make the learning curve that much easier.</p>
<h2 id="do-check-out-some-nix-resources.">Do check out some nix resources.</h2>
<p>The documentation for nix is fairly complete, but sometimes seems written by experts, for experts. Fortunately there are a few good introductory blog pieces around, many of them written by devs who appear to be heavily involved with the nix project. Here are a few in no special order that I found helpful:</p>
<ul>
<li><a href="https://www.domenkozar.com/2014/01/02/getting-started-with-nix-package-manager/">Domen Ko≈æar: getting started with nix</a></li>
<li><a href="http://lethalman.blogspot.it/2014/07/nix-pill-1-why-you-should-give-it-try.html">Lethalman‚Äôs Nix Pills Series</a></li>
<li><a href="http://fluffynukeit.com/series/haskell-nixos/">Setting Up Haskell Development on NixOS Linux from Scratch ¬´ fluffynukeit</a></li>
<li><a href="http://sandervanderburg.blogspot.com/2014/07/managing-private-nix-packages-outside.html">Sander van der Burg‚Äôs blog: Managing private Nix packages outside the Nixpkgs tree</a></li>
<li><a href="http://fuuzetsu.co.uk/blog/posts/2014-06-28-My-experience-with-NixOS.html">F≈´zetsu‚Äôs Corner: My experience with NixOS</a></li>
<li><a href="http://www.pavelkogan.com/2014/07/09/haskell-development-with-nix">Haskell development with Nix ¬∑ Pavel Kogan</a></li>
<li><a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55">Nix by example: The Nix expression language</a></li>
<li><a href="http://blog.matejc.com/blogs/myblog/control-your-packages-with-nix-environments/">Control your packages with Nix created profiles! - Matej Cotman‚Äôs Blog</a></li>
<li><a href="https://blog.kyleisom.net/nixos-experience-report/">NixOS Experience Report</a></li>
</ul>
<p>Special mention goes to a couple of blog posts by Ollie Charles, which convinced me to finally invest some serious time in nix.</p>
<ul>
<li><a href="https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html">How I Develop with Nix</a></li>
<li><a href="http://wiki.ocharles.org.uk/Nix#how-do-i-use-cabal2nix-for-local-projects">How I use cabal2nix</a></li>
</ul>
<p>It is also worth highlighting a few of the most helpful spots in the offical docs.</p>
<ul>
<li><a href="https://nixos.org/wiki/Nix_Modifying_Packages">Nix Modifying Packages - Nix Wiki</a></li>
<li><a href="http://nixos.org/nix/manual/#ssec-builtins">Nix User‚Äôs Guide-Builtins</a></li>
<li><a href="https://nixos.org/wiki/Haskell">Haskell - Nix Wiki</a></li>
<li><a href="https://nixos.org/wiki/Debugging_a_Nix_Package">Debugging a Nix Package - Nix Wiki</a></li>
<li><a href="http://nixos.org/nix/manual/#chap-writing-nix-expressions">Nix User‚Äôs Guide</a></li>
</ul>
<h2 id="do-refer-to-nix-packages-by-their-attribute-path-rather-than-their-name-whenever-possible.">Do refer to nix packages by their attribute path rather than their name whenever possible.</h2>
<p>The installation command <code>nix-env -i</code> lets you refer to packages either through their ‚Äúattribute path‚Äù or their package name. The latter is very slow due to the way the query tool currently works.</p>
<p>As a result, for me</p>
<pre><code>nix-env -iA nixpkgs.haskellPackages.SomeHaskellPkg</code></pre>
<p>is usually dramatically faster than</p>
<pre><code>nix-env -i haskell-some-haskell-pkg</code></pre>
<p>Where to find these attribute paths? You can do <code>nix-env -qaP</code> to get the attribute paths. For a while I was saving the output to a file and searching for packages there until I learned the next trick.</p>
<h2 id="do-install-nix-repl.">Do install nix-repl.</h2>
<p>It is as easy as</p>
<pre><code>nix-env -iA nixpkgs.nix-repl</code></pre>
<p>Having the repl available does a number of things for you. First, since nix uses the nix expression language for all its build recipes, nix-repl is like ghci for that language. You can play around with simple expressions to get used to the language. That will come in handy later.</p>
<p>nix-repl is also handy for inspecting available packages. Try this‚Ä¶</p>
<pre><code>$ nix-repl
nix-repl&gt; nixpkgs = import &lt;nixpkgs&gt;
nix-repl&gt; :a builtins
nix-repl&gt; attrNames nixpkgs
builtins.attrNames pkgs
[ &quot;AgdaSheaves&quot; &quot;AgdaStdlib&quot; &quot;DisnixWebService&quot; &quot;LASzip&quot; &quot;MPlayerPlugin&quot;
&quot;OVMF&quot; &quot;PPSSPP&quot; &quot;PatolineEnv&quot; &quot;R&quot; &quot;SDL&quot; &quot;SDL2&quot; &quot;SDL2_gfx&quot; &quot;SDL2_image&quot;
&quot;SDL2_mixer&quot; &quot;SDL2_net&quot; &quot;SDL_gfx&quot; &quot;SDL_image&quot; &quot;SDL_mixer&quot; &quot;SDL_net&quot; &quot;SDL_sound&quot;
&quot;SDL_ttf&quot;&quot;TotalParserCombinators&quot; &quot;VisualBoyAdvance&quot; &quot;Xaw3d&quot; &quot;ZopeInterface&quot;
&quot;_915resolution&quot; &quot;a2jmidid&quot; &quot;a52dec&quot; &quot;aacskeys&quot; &quot;aalib&quot; &quot;aangifte2006&quot;
&quot;aangifte2007&quot; &quot;aangifte2008&quot; &quot;aangifte2009&quot; &quot;aangifte2010&quot; &quot;aangifte2011&quot;
&quot;aangifte2012&quot; &quot;aangifte2013&quot; &quot;abc&quot; &quot;abc-verifier&quot; &quot;abcPatchable&quot; &quot;abcde&quot;
&quot;abduco&quot; &quot;abiword&quot; ... ]</code></pre>
<p>A total of 4430 packages appear in the output on my system. Let‚Äôs hunt for versions of ghc that are available.</p>
<pre><code>nix-repl&gt; attrNames nixpkgs.haskellP&lt;TAB&gt;
nix-repl&gt; builtins.attrNames nixpkgs.haskell
nixpkgs.haskell
nixpkgs.haskellPackages
nixpkgs.haskellPackages_ghc6104
nixpkgs.haskellPackages_ghc6123
nixpkgs.haskellPackages_ghc704
nixpkgs.haskellPackages_ghc722
nixpkgs.haskellPackages_ghc742
nixpkgs.haskellPackages_ghc763
nixpkgs.haskellPackages_ghc783
nixpkgs.haskellPackages_ghc783_no_profiling
nixpkgs.haskellPackages_ghc783_profiling
nixpkgs.haskellPackages_ghcHEAD
nix-repl&gt; exit</code></pre>
<p>This shows all the versions of ghc available including the latest bleeding edge version. The default is currrently 7.63 and ghcHEAD corresponds to an unreleased version of ghc. Many of these also have binary cached versions available, which install much faster and are exactly what you would get if you built them yourself.</p>
<p>You can also hunt specifically for Haskell packages. Let‚Äôs see what‚Äôs available for ghc 7.6.3.</p>
<pre><code>$ nix-repl
nix-repl&gt; nixpkgs.haskellPackages_ghc763.&lt;TAB&gt;
nixpkgs.haskellPackages_ghc763.ACVector
nixpkgs.haskellPackages_ghc763.AES
nixpkgs.haskellPackages_ghc763.Agda
nixpkgs.haskellPackages_ghc763.Allure
nixpkgs.haskellPackages_ghc763.BNFC
nixpkgs.haskellPackages_ghc763.BlogLiterately
nixpkgs.haskellPackages_ghc763.Boolean
nixpkgs.haskellPackages_ghc763.BoundedChan
nixpkgs.haskellPackages_ghc763.CCdelcont
nixpkgs.haskellPackages_ghc763.Cabal
nixpkgs.haskellPackages_ghc763.Cabal_1_16_0_3
nixpkgs.haskellPackages_ghc763.Cabal_1_18_1_3
nixpkgs.haskellPackages_ghc763.Cabal_1_20_0_2
...
nixpkgs.haskellPackages_ghc763.zippers
nixpkgs.haskellPackages_ghc763.zlib
nixpkgs.haskellPackages_ghc763.zlibBindings
nixpkgs.haskellPackages_ghc763.zlibConduit
nix-repl&gt; exit</code></pre>
<p>If you are using the default version of ghc, currently 7.6.3, you can omit reference to the compiler version and install a package like <code>zippers</code> this way.</p>
<pre><code>nix-env -iA nixpkgs.haskellPackages.zippers</code></pre>
<h2 id="do-fork-nixpgs.">Do fork nixpgs.</h2>
<p>Your nix installation already contains a complete copy of all the nix packages under <code>~/.nix-defexpr/channels/nixpkgs/</code>. This is called a channel, which bundles the ability to build all packages from source with the potential to install prebuilt binaries. These binaries are called a <em>substitute</em> in nix parlance and are a pure win if they are available, since your built-from-source package would be identical.</p>
<p>You can also have your own complete set of nix packages to play with. Just fork clone the repo over at <a href="https://github.com/NixOS/nixpkgs">https://github.com/NixOS/nixpkgs</a>.</p>
<p>One reason for forking nixpkgs is that you can update the repo to obtain the very latest versions. It‚Äôs perfectly ok to install packages either from your forked repo or your nix channel.</p>
<p>If you want to run different versions of ghc there is another reason to fork. I have a fork stored at <code>/timsears/code/nixpkgs</code>. I can open nix-repl again and point to the fork.</p>
<pre><code>nix-repl&gt; mynixpkgs = import /home/timsears/code/nixpkgs {}

nix-repl&gt; mynixpkgs.haskell
mynixpkgs.haskell
mynixpkgs.haskellPackages
mynixpkgs.haskellPackages_ghc6104
mynixpkgs.haskellPackages_ghc6123
mynixpkgs.haskellPackages_ghc704
mynixpkgs.haskellPackages_ghc722
mynixpkgs.haskellPackages_ghc742
mynixpkgs.haskellPackages_ghc763
mynixpkgs.haskellPackages_ghc783
mynixpkgs.haskellPackages_ghc783_no_profiling
mynixpkgs.haskellPackages_ghc783_profiling
mynixpkgs.haskellPackages_ghcHEAD</code></pre>
<p>Right now the list is the same as the one from my channel. But a couple of weeks ago, ghc 7.83 was only available through my forked repo.</p>
<p>Either way, this is cool. I would not dare to support so many versions of ghc on my ubuntu dev box.</p>
<h2 id="do-poke-around-the-nix-store.">Do poke around the nix store.</h2>
<p><em>Everything</em> to do with building packages ends up in <code>/nix/store</code>. When you first poke around in there it is a little bewildering. Do take a few <a href="http://lethalman.blogspot.it/2014/07/nix-pill-1-why-you-should-give-it-try.html">nix pills</a> and learn what‚Äôs what. The <code>.drv</code> files are what nix calls derivations. These files relate all the input and output files connected to building a package. All those inputs and outputs are isolated from each other and stored in their own subdirectory under <code>/nix/store</code>. Any dependencies of installed packages are there too, along with dependencies of dependencies, and so forth. You may have several versions of the same package if two downstream packages need different versions. It is probably not too surprising that all the outputs are there, but what about the inputs? Why keep them? Nix keeps references to <em>everything</em> needed to build and reproduce a build exactly. Having nix know the inputs essentially provides the proof that the output will be the same. Nix can even locate binary caches of those builds if available elswhere. That‚Äôs the benefit of purity. Nix starts to look very much like a memoized Haskell function.</p>
<h2 id="do-understand-profiles.">Do understand profiles.</h2>
<p>There at least three ‚Äúlocations‚Äù to install packages in nixos: the system, user-profile and per-project.</p>
<h3 id="system-level-install.">System level install.</h3>
<p>You can add packages to <code>/etc/configuration.nix</code> as I have done <a href="https://gist.github.com/timsears/46be2bc972909913770a">here</a>. This makes them available to all user profiles. There‚Äôs probably only one real user on your dev box, but this is still a useful option. For example, you may want to have multiple user profiles to segregate packages that don‚Äôt play nice, but you still don‚Äôt want to reinstall packages like emacs everywhere. If you prefer not to edit this file you can create a custom set of packages that every user profile can install. I won‚Äôt talk about this further here, but I am interested to hear other nix users‚Äô comments on easy ways to manage sets of common packages.</p>
<h3 id="user-profile-installs">User profile installs</h3>
<p>You can also install packages in your default profile <code>nix-env -iA nixpkgs.somePackage</code> and that‚Äôs fine. Eventually you will need to manage groups of packages that do not play nice, such as different versions of ghc and their corresponding libraries. Let‚Äôs create two new user profiles. In <code>so2013</code> we will run ghc 7.42 and in the profile <code>letitbleed</code> we will run <code>ghcHEAD</code> which corresponds to an unreleased ghc 7.9.</p>
<p>Nix was designed by folks unafraid of long pathnames, so here‚Äôs how you are supposed to do it.</p>
<pre><code>$ nix-env --switch-profile /nix/var/nix/profiles/per-user/timsears/so2013
$ nix-env -q --confirm it&#39;s an empty profile
$ nix-env -iA nixpkgs.haskellPackages_ghc742.ghc</code></pre>
<p>Run <code>ghc --version</code> to confirm that it worked.</p>
<p>Let‚Äôs add an old favorite, hmatrix, to the profile. It‚Äôs known to work with ghc 7.4.</p>
<pre><code>$ nix-env -iA nixpkgs.haskellPackages.hmatrix</code></pre>
<p>You should now be able to see something like this.</p>
<pre><code>$ nix-env -q
ghc-7.4.2-wrapper
haskell-hmatrix-ghc7.4.2-0.16.0.6</code></pre>
<p>We can now repeat the process to set up our <code>letitbleed</code> profile.</p>
<pre><code>$ nix-env --switch-profile /nix/var/nix/profiles/per-user/timsears/letitbleed
$ nix-env -iA nixpkgs.haskellPackages_ghcHEAD.ghc
$ nix-env -iA nixpkgs.haskellPackages_ghcHEAD.hmatrix</code></pre>
<p>The system responds with</p>
<pre><code>installing `haskell-hmatrix-ghc7.9.20141106-0.16.0.6-shared&#39;
... output omitted ...
Creating package registration file:
/nix/store/d0wccnkgjgxikh1l4hs9c3s4jnyqfzgq-haskell-hscolour-ghc7.9.20141106-1.20.3-shared/lib/ghc-7.9.20141106/package.conf.d/hscolour-1.20.3.conf
ghc-pkg: ghc no longer supports single-file style package databases (/nix/store/d0wccnkgjgxikh1l4hs9c3s4jnyqfzgq-haskell-hscolour-ghc7.9.20141106-1.20.3-shared/lib/ghc-7.9.20141106/package.conf.d/hscolour-1.20.3.installedconf) use &#39;ghc-pkg init&#39; to create the database with the correct format.
[q[qbuilder for `/nix/store/vvf2ml647ms6c07885i190ay8b5gznhb-haskell-hscolour-ghc7.9.20141106-1.20.3-shared.drv&#39; failed with exit code 1
cannot build derivation `/nix/store/0b0dgss2dpl0vnfqmvdnbr66n4vzk3g7-haskell-hmatrix-ghc7.9.20141106-0.16.0.6-shared.drv&#39;: 1 dependencies couldn&#39;t be built
error: build of `/nix/store/0b0dgss2dpl0vnfqmvdnbr66n4vzk3g7-haskell-hmatrix-ghc7.9.20141106-0.16.0.6-shared.drv&#39; failed</code></pre>
<p>Boom! Looks like the dependency hscolour does not install, confirming we have indeed arrived on the bleeding edge. We‚Äôll leave that for another day.</p>
<h3 id="project-level-installs">Project level installs</h3>
<p>When building your own code with nix you can hide your system and user profiles to build code in a more or less clean environment using <code>nix-build</code> and <code>nix-shell</code>. You don‚Äôt really install packages, you declare dependencies. I will get into more detail in a later post.</p>
<h1 id="next-time">Next Time</h1>
<p>As long as this post turned out to be, it was still too short to cover how to hack on a more realistic project. For that we need to cover <code>cabal2nix</code> and be able to read and modify nix expressions. We will also need to point nix at our own source code and prevent it from doing crazy things like copying our entire git repo into the nix store.</p>
]]></summary>
</entry>
<entry>
    <title>I am trying nixos</title>
    <link href="http://blog.timsears.com/posts/im_trying_nix.html" />
    <id>http://blog.timsears.com/posts/im_trying_nix.html</id>
    <published>2014-10-16T00:00:00Z</published>
    <updated>2014-10-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="my-setup">My setup<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></h1>
<p>I have been running ubuntu 12.04 on VMWare Fusion. I started using nixos on October 6th.</p>
<p>That‚Äôs just 10 days ago.</p>
<p><em>Disclaimer: All opinions herein are subject to change.</em></p>
<h1 id="my-current-setup-has-its-pluses">My current setup has its pluses‚Ä¶</h1>
<ul>
<li>Ubuntu is very stable, never crashes. I have never felt pressure to upgrade from 12.04.</li>
<li>Security upgrades have never broken anything.</li>
<li><code>sudo apt-get install somepackage</code> rarely fails to provide what I need.</li>
<li>Binary/libc compatible with our servers in the cloud. Easy deployment on minimially configured production box.</li>
</ul>
<h1 id="and-its-minuses">‚Ä¶and its minuses</h1>
<ul>
<li>ghc is <em>always</em> behind in the package manager (ubuntu 12.04 ~ ghc 7.4). I want to work on projects that require ghc 7.8.</li>
<li>My dev box is used for building production code.</li>
<li>Only <em>my</em> code is should break a build. Therefore I don‚Äôt want to install software that could break my code.</li>
<li>Setting up a dev box for a new person requires reading lots of old and potentially outdated notes to collect and install all sorts of dependencies together on a new box.</li>
<li>The new cabal sandboxes work, but lots of code gets recompiled and reinstalled on every project.</li>
<li>It‚Äôs ‚Äúhard‚Äù to run multiple versions of ghc. (I might just be lazy here.)</li>
</ul>
<h1 id="some-suggestions-i-have-heard">Some suggestions I have heard</h1>
<p>‚ÄúBro, you‚Äôre running a mac. Just use brew.‚Äù</p>
<ul>
<li>I have tried everything on mac. Remember fink, ports?</li>
<li>brew is great. It makes make osx 99% like linux. Not nearly close enough.</li>
<li>Did you ever cross-compile with ghc?</li>
</ul>
<p>‚ÄúDude, you like the bleeding edge. Try Arch.‚Äù</p>
<ul>
<li>No, it just looks that way because I use Haskell.</li>
<li>I did run Arch for over a year. Arch is fun, has a great community and a fantastic wiki, but if you want to update one thing you need to update everything. You tend to run only the latest software and it is hard to roll back.</li>
<li>I broke my system more than once.</li>
</ul>
<h1 id="why-nixos">Why Nixos?</h1>
<p>As a Haskeller how could I resist this kind of marketing?</p>
<blockquote>
<p>Nixos: The Purely Functional Linux Distribution</p>
</blockquote>
<p>But wait there‚Äôs more!</p>
<blockquote>
<p>Built on top of the Nix package manager, it is completely declarative‚Ä¶</p>
</blockquote>
<p>Whoa.</p>
<h1 id="real-reasons">Real reasons:</h1>
<p>The potential‚Ä¶</p>
<ul>
<li>for alternative environents to live safely on the same box. (nix)</li>
<li>to encode the configuration of a development box suitable for my company‚Äôs project. (nixos, nix).</li>
<li>to <em>calculate</em> an entire machine and deploy it to the cloud. (nixops)</li>
<li>Escape cabal hell forever without pinning all my dependencies.</li>
<li>Let‚Äôs try it out‚Ä¶</li>
</ul>
<h1 id="install">Install</h1>
<p>Boot a new machine from a .iso file, then‚Ä¶</p>
<pre><code>$ fdisk /dev/sda # enter options n,p,1,w in sequence
$ mkfs.ext4 -j -L nixos /dev/sda1
$ mount LABEL=nixos /mnt
$ nixos-generate-config --root /mnt
$ nano /mnt/etc/nixos/configuration.nix # copy/paste a configuration.nix.
$ nixos-install
$ reboot</code></pre>
<p>While it is truly possible to get a system going this way, I edited configuration about 20 times before I had it just right for my dev box. If you break something the old configuration is available from the boot menu.</p>
<p>Here‚Äôs my config file‚Ä¶</p>
<pre><code>[timsears@nixos:~/blog/drafts]$ cat /etc/nixos/configuration.nix
# Edit this configuration file to define what should be installed on
# your system.  Help is available in the configuration.nix(5) man page
# and in the NixOS manual (accessible by running ‚Äònixos-help‚Äô).

{ config, pkgs, ... }:

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  # Use the GRUB 2 boot loader.
  boot.loader.grub.enable = true;
  boot.loader.grub.version = 2;
  # Define on which hard drive you want to install Grub.
  boot.loader.grub.device = &quot;/dev/sda&quot;;

  swapDevices = [ { device = &quot;/swapfile1&quot;; } ];

  networking.hostName = &quot;nixos&quot;; # Define your hostname.
  # networking.wireless.enable = true;  # I&#39;m on a vm. Not needed.

  # Select internationalisation properties.
  i18n = {
    consoleFont = &quot;lat9w-16&quot;;
    consoleKeyMap = &quot;us&quot;;
    defaultLocale = &quot;en_US.UTF-8&quot;;
  };

  environment.systemPackages = with pkgs; [
    (pkgs.texLiveAggregationFun { paths = [ pkgs.texLive pkgs.texLiveExtra pkgs.texLiveBeamer ]; })
     wget
     curl
     emacs
     xlibs.xmessage
     xfce.terminal
   ];

  nixpkgs.config.allowUnfree = true;

  time.timeZone = &quot;US/Pacific&quot;;
  security.sudo.wheelNeedsPassword = false;

  # List services that you want to enable:

  # Enable the OpenSSH daemon.
  services.openssh.enable = true;

  services.xserver = { displayManager.slim.autoLogin = true;
                       displayManager.slim.defaultUser = &quot;timsears&quot;;
                       windowManager.awesome.enable = true;
                       windowManager.default = &quot;awesome&quot;;
                       # only seem to affect login screen
                       virtualScreen = { x = 1920; y = 1200; };
                       resolutions = [{ x = 1920; y = 1200; }] ;
                       enable = true;
                       layout = &quot;us&quot;;
                        };

  # Define a user account. Don&#39;t forget to set a password with ‚Äòpasswd‚Äô.
  users.extraUsers.guest = {
    name = &quot;timsears&quot;;
    group = &quot;users&quot;;
    extraGroups = [&quot;wheel&quot;];
    uid = 1000;
    createHome = true;
    home = &quot;/home/timsears&quot;;
    shell = &quot;/run/current-system/sw/bin/bash&quot;;
   };
}</code></pre>
<h1 id="configure-global">Configure (Global)</h1>
<p>There are at least three levels of configuration. Global-, user- and project- level. We already saw global level. Software packages can be enabled here‚Ä¶</p>
<pre><code>nano /etc/nixos/configuration.nix # make changes
nixos-rebuild switch</code></pre>
<p>It‚Äôs really about that simple.</p>
<h1 id="configure-user">Configure (User)</h1>
<p>You are encouraged to install software as a user with <code>nix-env -i somepackage</code> See installed packages with <code>nix-env -q</code>. Here‚Äôs mine so far‚Ä¶</p>
<pre><code>cabal-install-1.16.0.2
cabal2nix-1.61
chromium-stable-with-plugins-35.0.1916.114
ghc-7.6.3-wrapper
git-1.9.4
gnome-terminal-3.10.2
haskell-hakyll-ghc7.6.3-4.5.1.0
haskell-haskell-platform-ghc7.6.3-2013.2.0.0
haskell-hoogle-ghc7.6.3-4.2.32
hasktags-0.68.7
nix-repl-1.7-1734e8a
structured-haskell-mode-1.0.2
w3m-0.5.3
xkill-1.0.4
xpdf-3.03</code></pre>
<p>Eventually I will convert that to a nix expression. I expect to write a few custon expressions to install the odd missing package (like easyVision).</p>
<h1 id="configure-project">Configure (Project)</h1>
<p><strong>Here‚Äôs our first major win</strong></p>
<p>You can have multiple profiles per user. (I haven‚Äôt used that feature yet.)</p>
<p>Or you can customize the build environment for each project.</p>
<p>You can put a nix expression in a project directory. Here‚Äôs a file that lives in a project I have been working on: <code>~/timsears/code/probmonad/default.nix</code></p>
<pre><code>{ pkgs ? (import &lt;nixpkgs&gt; {})
#, haskellPackages ? pkgs.haskellPackages_ghc763
, haskellPackages ? pkgs.haskellPackages_ghc782
}:

let inherit (haskellPackages) cabal cabalInstall
    distributive comonad; # Haskell dependencies here
in

haskellPackages.cabal.mkDerivation (self: {
  pname = &quot;probmonad&quot;;
  version = &quot;0.1.0.0&quot;;
  src = &quot;./.&quot;;
  isLibrary = false;
  isExecutable = true;
  buildTools = with haskellPackages; [cabalInstall];
  buildDepends = with haskellPackages; [ comonad distributive];
  meta = {
    license = self.stdenv.lib.licenses.gpl3;
    platforms = self.ghc.meta.platforms;
  };
  noHaddock = true;
})</code></pre>
<h1 id="why-this-is-great">Why this is great</h1>
<ul>
<li><p>The default.nix file is mostly generated by a utility <code>cabal2nix</code>.</p></li>
<li><p>I can comment out one line to switch ghc versions distributions. I just enter <code>nix-shell</code> to drop into the chosen environment. <strong>Other projects are unaffected.</strong></p></li>
<li><p>The first time you switch versions nix downloads and caches all the necessary packages. (Lazy evaluation!)</p></li>
<li><p>I can even hide my default environment to make sure there are no hidden dependencies in my build expression.</p></li>
<li><p>Dependencies can be <em>anything</em>. Nix will install them for you if there is a nix expression available.</p></li>
</ul>
<h1 id="impressions-so-far">Impressions so far</h1>
<h2 id="the-good">The Good</h2>
<ul>
<li>Switching environments works well and fast after the initial setup. It‚Äôs really the first time I have been happy doing that.</li>
<li>The entire set of package expressions is in one git repo. That‚Äôs cool.</li>
<li>You literally edit one file to configure your box globally. That‚Äôs really cool.</li>
<li>Rolling back a bad configuration is really easy.</li>
</ul>
<h2 id="the-bad">The Bad</h2>
<ul>
<li>You <em>must</em> learn how nix expressions work.</li>
<li>The docs aren‚Äôt great yet. You must read the code!</li>
<li>Nobody told me to read the manual‚Äôs Appendix B first to see all the settings available for configureing your system. There, I told <em>you</em>.</li>
<li>Sometimes blogs are more helpful than the docs.</li>
</ul>
<h2 id="the-i-dont-know">The I Don‚Äôt Know</h2>
<ul>
<li>nixops looks powerful. I want to try it.</li>
<li>Some things are still arcane or rough around the edges (installing latex).</li>
<li>Will I be able to write an expression for Intel IPP? It‚Äôs got a weird installer.</li>
</ul>
<p>[EDIT: There is a video of the talk I gave <a href="http://looprecur.com/blog/from-ubuntu-to-nixos/">here</a> and a Reddit discussion <a href="http://www.reddit.com/r/haskell/comments/2k3oy2/from_ubuntu_to_nixos_video/">here</a> ]</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This blog enty was based on a talk I gave at Hacker Dojo earlier today.<a href="#fnref1">‚Ü©</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Free Monads Just Got Cheaper</title>
    <link href="http://blog.timsears.com/posts/Free_Monads_Just_Got_Cheaper.html" />
    <id>http://blog.timsears.com/posts/Free_Monads_Just_Got_Cheaper.html</id>
    <published>2014-09-09T00:00:00Z</published>
    <updated>2014-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>One of the more exciting papers I have read recently is <a href="http://homepages.cwi.nl/~ploeg/papers/zseq.pdf">‚ÄúReflection without Remorse: Revealing a hidden sequence to speed up monad reflection‚Äù</a> by Ploeg &amp; Kiselyov. It was presented at ICFP by one of the authors and the video is <a href="https://www.youtube.com/watch?v=_XoI65Rxmss">here</a>. The paper, hereafter referred to as RWR, provides fiendishly a clever way to speed up the performance of programs that are structured using monads. In Haskell, that means lots of programs. Half algorithm, half technique, the paper presents a number of applications to specific monads. I was particularly interested in the case of free monads, which is covered in this post.</p>
<h2 id="inefficiency-by-association">Inefficiency By Association</h2>
<p>So what‚Äôs the problem being addressed? Even if you have just a little familiarity with Haskell you might remember learning about performance issues related to the list append operation, <code>++</code>, and be able to tell which side of the following expression is more efficient:</p>
<pre class="haskell"><code>last ((xs ++ ys) ++ zz)) == last (xs ++ (ys ++ zs))</code></pre>
<p>To see why the right hand side is faster, take a look at these definitions from the Haskell Prelude.</p>
<pre class="haskell"><code>(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)

last             :: [a] -&gt; a
last [x]         =  x
last (_:xs)      =  last xs
last []          =  error &quot;Prelude.last: empty list&quot;</code></pre>
<p>In order to get the last element of the list, <code>last</code> needs to traverse the entire list. That‚Äôs not the issue in question, but it does mean that all references to the recursively defined <code>++</code> must be dispensed with before <code>last</code> starts evaluating. In other words, we must completely build the list during the computation. Looking at the second definition of <code>++</code>, you can see that the right hand input is left alone, but the left hand list is traversed. That means <code>xs</code> in the example will be traversed twice in the left hand side but only once on the right.</p>
<p>The list expressions in the example correspond to little trees built according to where we place the parentheses. The associative law lets us move parens around or even erase them, so that we can just write</p>
<pre><code>xs ++ ys ++ zs</code></pre>
<p>without even thinking about which little tree is actually used to build the list. The trouble is that some operations prefer the list to be built one way or vice versa. One bit of intuition is that the RWR solution takes the construction above seriously. It looks like a sequence with <code>++</code> as a ‚Äúconstructor‚Äù, and there are some fast data structures to build sequences that we don‚Äôt use enough in Haskell.</p>
<p>This performance question is not confined to lists and the <code>++</code> operation alone. The same issue crops up in other data structures like trees and monads. Known optimizations and workarounds can help speed up some applications, but often at the cost of slowing down others. Lists, trees and monads all share a similar structure. In fact, it‚Äôs all the same structure‚Äîlists are an extreme form of tree and monads are really a tree of computations, a point nicely made in a <a href="http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html">sigfpe blog post</a>:</p>
<blockquote>
<p>Instances of type class Monad can be thought of as trees describing ‚Äòcomputations‚Äô. The Monad interface provides a way to graft subtrees into trees. There are as many types of ‚Äòcomputation‚Äô as there are interpreters for tree structures. In practice the interpretation is interleaved with the graft operation so that we don‚Äôt have separate tree-building and interpretation phases.</p>
</blockquote>
<p>The grafting mentioned requires traversals just like in the simple example above, and it can lead to inefficiencies if they are nested the ‚Äúwrong‚Äù way. Same as before, the meaning of the computation is not affected since the same tree can be built in multiple ways, thanks to the monadic version of the associative law:</p>
<pre class="haskell"><code>(m &gt;&gt;= f) &gt;&gt;= g  ==  m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></pre>
<p>The analogy between <code>++</code> and <code>&gt;&gt;=</code> is hopefully clear even though an abstraction (that lambda) is introduced.</p>
<p>So, what does the RWR solution do about all these equivalent trees? It took me a couple of times reading the paper for the solution to start to sink in. Feeling rather dense, I remembered this:</p>
<blockquote>
<p>‚ÄúIn mathematics you don‚Äôt understand things. You just get used to them.‚Äù ‚ÄîJohn von Neumann</p>
</blockquote>
<p>Even better, this is software, where we can edit the motto: ‚ÄúIn computer science you don‚Äôt need to understand things, you just have to use them‚Äù. It turns out that can help us understand things too.</p>
<h2 id="free-as-in-monads">Free, as in Monads</h2>
<p>Let‚Äôs go straight to the api for free monads.</p>
<p>Free monads are interesting as one way to create <a href="http://www.haskell.org/haskellwiki/Embedded_domain_specific_language">embedded domain specific languages (DSLs)</a> in Haskell. There are several approaches ranging from <em>deep embedding</em> to <em>shallow embedding</em>. A free monad comes from the deep end of the embedding pool.</p>
<p>Deep embedding has the nice feature that you can implement interpreters that do all kinds of different things with the same program. You can have an interpreter that can evaluate your program, a second one that can pretty print it, and a third interpreter that translates the very same program to run on a cluster. Sexy, no?</p>
<h2 id="example-dsl">Example DSL</h2>
<p>We will look at a toy example DSL adapted from John Wiegley‚Äôs <a href="http://newartisans.com/2012/08/meta-programming-with-the-free-monad/">blog</a>. If you have never seen the technique, go read that short piece or this <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">one</a>. Or, make do with the quick summary below.</p>
<p>To build your DSL, you start with a data type with multiple constructors. Each constructor represents a valid command in your DSL. Next, add a type parameter to each constructor for any command that can continue execution. Make the new type an instance of <code>Functor</code>. (The compiler can even do that for you automatically.) Finally, make the functor a free monad instance. This last step lets us use <code>do</code>-notation, and we can then structure our programs more like normal Haskell programs. We can optionally add functions that hide some of the plumbing, to make the programs look even nicer.</p>
<p>That plan plays out in the example below, a tiny imperative DSL that gives us an imperative robot control language with just three commands: go left, go right, and stop (forever). They appear as the constructors of <code>FDirective</code>.</p>
<pre class="haskell"><code>import qualified Control.Monad.Free as F

-- Commands, for
data FDirective next = FL next | FR next | FS
  deriving (Functor, Show)</code></pre>
<p>With just one more line we can make a free monad out of our data type, and then add a little syntactic sugar (<code>left'</code>, <code>right'</code>, <code>shutdown'</code>) so our program will look nice.</p>
<pre class="haskell"><code>-- Traditional Free Monad
type TFM a = F.Free FDirective a

left&#39;     = F.liftF (FL ())
right&#39;    = F.liftF (FR ())
shutdown&#39; = F.liftF FS
</code></pre>
<p>We can already write an evaluation interpreter</p>
<pre class="haskell"><code>interpret&#39; :: TFM a -&gt; IO ()
interpret&#39; (F.Free (FL f)) = putStrLn &quot;Going left&quot;  &gt;&gt; interpret&#39; f
interpret&#39; (F.Free (FR f)) = putStrLn &quot;Going right&quot; &gt;&gt; interpret&#39; f
interpret&#39; (F.Free FS)     = putStrLn &quot;Saw shutdown, stopping&quot;
interpret&#39; (F.Pure _)      = error &quot;Improper termination&quot;</code></pre>
<p>And we can now write a small program.</p>
<pre class="haskell"><code>instrs&#39; :: F.Free FDirective a
instrs&#39; = do
  left&#39;
  right&#39;
  left&#39;
  shutdown&#39;</code></pre>
<p>How much work is it to apply the RWR solution? Not that much. I modified the code from the example above and followed the suggestion of using the <code>LANGUAGE ViewPatterns</code> pragma to make the code even easier to look at. Here‚Äôs the result.</p>
<pre class="haskell"><code>type FM a = FreeMonad FDirective a

interpret :: FM a -&gt; IO ()
interpret (toView -&gt; Impure (FL f)) =
  putStrLn &quot;Going left&quot; &gt;&gt; (interpret f)
interpret (toView -&gt; Impure (FR f)) =
  putStrLn &quot;Going right&quot; &gt;&gt; (interpret f)
interpret (toView -&gt; Impure FS) = putStrLn &quot;Saw shutdown, stopping&quot;
interpret (toView -&gt; Pure _ )  = error &quot;Improper termination&quot;

left :: FreeMonad FDirective ()
left = liftF $ FL () -- same as `fromView $ Impure FR``
right = liftF $ FR ()
shutdown = liftF $ FS

liftF :: Functor f =&gt; f a -&gt; FreeMonad f a
liftF x = fromView $ Impure (fmap return x)

instrs :: FM ()
instrs =
 do left
    right
    left
    shutdown

main :: IO ()
main = interpret instrs</code></pre>
<p>The output from either example is the same of course</p>
<pre class="haskell"><code>Œª&gt; main
Going left
Going right
Going left
Saw shutdown, stopping</code></pre>
<p>In the new version <code>FreeMonad</code> corresponds to <code>F.Free</code> from the first version. The only significant difference in the code is the appearance of the <code>toView</code> and <code>fromView</code> functions. The <code>toView</code> function is needed whenever your interpreter needs to pattern match on a command and the <code>fromView</code> is effectively just a constructor. That‚Äôs it!</p>
<h2 id="under-the-covers">Under the Covers</h2>
<p>Under the covers, the RWR approach to monads is doing a lot. It factors the monad into a pair of mutually recursive data structures: a view and a builder. The builder is a sequence of views, and the view is a tree of builders. The view gives you partial access to the entire computation. If you need to pattern match part of the computation you must use the view. Part of the magic is contained in the data structure used for the sequence, which is the same for all monads, and the rest of the magic is in the conversion from builder to view, which needs to be figured out for each monad. That‚Äôs why RWR is half algorithm, half technique. Of course for free monads, the solution has been worked out for <em>every</em> free monad. Very handy.</p>
<p>Let‚Äôs take a peek under the covers at the library code. The relevant file is <a href="https://github.com/timsears/reflectionwithoutremorse/blob/cabalize/src/Fixed/FreeMonad.hs">here</a> and the key section appears below.</p>
<pre class="haskell"><code>type TCQueue = FastTCQueue

newtype FC f a b = FC (a -&gt; FreeMonad f b)

type FMExp f a b = TCQueue (FC f) a b

data FreeMonad f a =
   forall x. FM (FreeMonadView f x) (FMExp f x a)

data FreeMonadView f a 	= Pure a | Impure (f (FreeMonad f a))</code></pre>
<p>As mentioned, a free monad value consists of a pair of calculations. The first one is a <code>FreeMonadView</code> that contains the part of the calculation in a form you might expect to see from the traditional free monad. The second part is a sequence of monadic functions (<code>FMExp</code>) that eventually get composed to make up the rest of the calculation. The sequence is implemented as a data structure with fast updates to either end of the sequence‚Äîone that has been generalized to handle elements of different types as can happen with all the statements in a DSL. Did I mention it was clever?</p>
<p>Enough peeking, we have morals, right? So let‚Äôs get back above the covers. It‚Äôs simple enough to try this on some other DSLs and compare performance, which I hope to do soon.</p>
<h2 id="getting-the-code">Getting the Code</h2>
<p>The RWR paper offers code with all the monad solutions from the paper and more <a href="https://github.com/atzeus/reflectionwithoutremorse">here</a>. There‚Äôs no corresponding hackage library that I could find. Given the pace of development on hackage these days I could be wrong, or soon will be.</p>
<p>So, I forked the code, cabalized it and fixed a couple of things that were needed to make it compile. That code is <a href="https://github.com/timsears/reflectionwithoutremorse/tree/cabalize">here</a>. The complete code for the toy DSL example is contained in this <a href="https://gist.github.com/timsears/61cda5fa8378d584c538">gist</a>.</p>
]]></summary>
</entry>
<entry>
    <title>Predictions from the Past, Hope for the Futurist</title>
    <link href="http://blog.timsears.com/posts/Predictions_from_the_Past.html" />
    <id>http://blog.timsears.com/posts/Predictions_from_the_Past.html</id>
    <published>2014-07-24T00:00:00Z</published>
    <updated>2014-07-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Nobody can deny the huge impact that technology has had on many areas of work, play, and family. Entire industries have been born, prospered, and died all within in a few years (remember Blockbuster?). These days, the only thing that may be surprising is how small the impact has been had on a few nooks and crannies of the economy and life. But hang on a decade, will you? 3D printers, drones and immersive displays are just getting started.</p>
<p>The hype sometimes reminds me of when I was a kid and the European-themed Busch Gardens amusement park opened in Williamsburg, Virginia. The rides were said to be <em>amazing</em>. As a 14-year old, I took a special interest in its progress. When my friend Tony went with his family, I was eager to hear his report. He said, ‚ÄúMy Dad says nobody will ever need to go to Europe anymore. They have everything at Busch Gardens‚Äîthe Eiffel Tower, Picadilly Circus, even a Bavarian beer garden‚Äîand it‚Äôs <em>better</em>.‚Äù</p>
<p>Don‚Äôt get me wrong, I can‚Äôt wait to work on all the new stuff. In fact, the other day I was discussing the Internet of Things applied to cows with some colleagues. I just expect Europe to still be in business when I‚Äôm done building the Internet of Cows.</p>
<p>Blockbuster lives the short life of a firefly, while Busch Gardens and European tourism survive. Is there any way to predict things like this? A hundred years ago, planes, electricity, and automobiles were just starting to spread. Other technologies like steam engines and railroads were practically old hat. People of the era had plenty of imagination, and some of them made some fairly accurate predictions. You can look at these <a href="http://singularityhub.com/2012/10/15/19th-century-french-artists-predicted-the-world-of-the-future-in-this-series-of-postcards/">French postcards</a> or <a href="http://www.wired.com/2014/05/victorian-postcards-predict-future/">these</a>, or these <a href="http://www.paleofuture.com/blog/2007/4/24/postcards-show-the-year-2000-circa-1900.html">German ones</a> or this <a href="http://www.bbc.com/news/magazine-16444966">American article</a>, all from around that time to see a wide range of predictions, almost all related to technology. If you look past the steam punk aesthetic it‚Äôs really surprising to see how many things they got right. The conclusion is that our collective imaginations can take us pretty far if some trends, like human flight, are already in place.</p>
<h1 id="a-weekend-on-the-moon">A Weekend on the Moon?</h1>
<div class="nostretch">
<img src="/images/moon.jpg" alt="Weekend on the Moon?" />
</div>
<p><br></p>
<p>We can also look at these predictions and see a few enormous errors, even if that doesn‚Äôt seem fair. For example, there‚Äôs the forecasted <a href="http://www.bbc.com/news/magazine-16444966">political union of Nicaragua and the U.S.A.</a>. Nobody expected the Sandinistas or the current House Republicans, I guess. Then there‚Äôs the weekend trip to the moon, or the <a href="http://www.wired.com/wp-content/uploads/2014/05/Wired9.jpg">chimney sweep with his own helicopter</a>. They got the technology right, but the costs are way off.</p>
<p>Certain biases look very pronounced. Perhaps we still have them too. What are they?</p>
<h3 id="its-hard-to-predict-fashion.">It‚Äôs hard to predict fashion.</h3>
<p>Nobody is wearing skinny jeans in those images, although the men seem to have beards. We all predict a future in which we will all be wearing the same clothes we have on now.</p>
<h3 id="its-also-hard-to-predict-politics-and-social-change.">It‚Äôs also hard to predict politics and social change.</h3>
<p>Maybe that‚Äôs why nobody predicted things like Hitler or Twitter. Perhaps the success of Twitter and the failure of almost every famous economist has by now turned futurists away from predictions about social change. While I definitely predict the Internet of Cows, I refuse to say what they will do with it.</p>
<h3 id="futurists-tend-to-neglect-energy-prices.">Futurists tend to neglect energy prices.</h3>
<p>Can you even guess how many tons of coal it takes to go to the moon for the weekend? Well I‚Äôm too busy to calculate it too, but surely it would have ruled that one out. Take note Richard Branson. This might come as a shock, but energy prices have not really changed dramatically over the last hundred years. That‚Äôs right, gasoline prices have stayed almost within a <a href="http://inflationdata.com/Inflation/Inflation_Rate/Gasoline_Inflation.asp">factor of two</a> during the period, in real terms of course. On the other hand, nobody predicted nuclear weapons until a few years later. The price of high energy weapons fell off the table, but the cost of making this energy safe remains extremely high, so it hasn‚Äôt <a href="http://en.wikipedia.org/wiki/Economics_of_nuclear_power_plants">brought much benefit</a> so far. Memo to futurists: Factor in current energy prices, or tell us where the cheap energy is coming from.</p>
<h3 id="people-are-very-optimistic-when-estimating-the-difficulties.">People are very optimistic when estimating the difficulties.</h3>
<p>Robot haircuts? Maybe soon, but you go first please. Too dangerous for me. Yes, we had the predicted flying bombers by the time WWII came around, but they were deathtraps. Not only laymen have this problem, experts practically specialize in it. Machines are amazing at calculating bank statements and have been for over forty years. They are also really good at collecting tolls and routing pictures of cats around the world. They can land airplanes, but they only started beating chess grandmasters consistently in the past few years. It‚Äôs only obvious in retrospect. Nobody knows quite when machines will <a href="http://en.wikipedia.org/wiki/Computer_Go">beat Go masters</a> or give good haircuts. Of course this is all about software. In this field, we seem to have a hard time understanding what computers can and can‚Äôt do even now. The boundary between easy and hard, solved and unsolved problems is very ill-defined. For example, one of my former colleagues recently developed a computer program that was able to beat humans at answering this simple question about a photo: <a href="http://www.theregister.co.uk/2013/11/15/google_thinking_machines/">Is there a paper shredder here?</a> It turns out he needed <a href="http://en.wikipedia.org/wiki/Deep_learning">Deep Learning</a> and weeks of processing to train it and we can‚Äôt ask the program any other questions besides ‚ÄúShredder there?‚Äù. Would you guess it would be that hard?</p>
<div class="nostretch">
<img src="/images/robot-barber.jpg" alt="Not too much off the top!" />
</div>
<p><br></p>
<h1 id="a-future-for-futurists">A Future for Futurists</h1>
<p>My advice to futurists is this: Avoid predictions based on crazy low energy prices. Stay away from politics, society, and fashion. I would include Blockbuster shares here. Base your predictions on technology trends that are firmly in place but not fully exploited. And if it takes a lot of work to accomplish the prediction, so much the better. We‚Äôll get there and you will look prescient in the end.</p>
<p>Perhaps in a future post, I will take some inspiration from those old French postcards and try my hand at some forecasts in the field of machine learning and computer science. Some trends are in place that should make it ‚Äúeasy‚Äù to see some of the things that will likely emerge. With any luck, I will avoid predicting perpetual motion.</p>
]]></summary>
</entry>

</feed>
